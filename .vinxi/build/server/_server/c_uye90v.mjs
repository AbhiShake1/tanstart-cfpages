import{jsxs as C}from"react/jsx-runtime";import{defaultTransformer as O,isRedirect as S,isNotFound as F,createFileRoute as T,lazyRouteComponent as j,lazyFn as H,useRouter as M}from"@tanstack/react-router";import{i as E,s as R,b as $}from"./http.mjs";import"h3";import"node:async_hooks";function p(e,n,t){return Object.assign(e,{url:"https://localhost:3000"})}function A(e){return e instanceof Headers?new Headers(e):Array.isArray(e)?new Headers(e):typeof e=="object"?new Headers(e):new Headers}function I(...e){return e.reduce((n,t)=>{const r=A(t);for(const[o,s]of r.entries())n.set(o,s);return n},new Headers)}const P=[];function u(e,n){const t=n||e||{};return typeof t.method>"u"&&(t.method="GET"),{options:t,middleware:r=>u(void 0,Object.assign(t,{middleware:r})),validator:r=>u(void 0,Object.assign(t,{validator:r})),handler:(...r)=>{const[o,s]=r;Object.assign(t,{...o,extractedFn:o,serverFn:s}),E(o.url);const i=[...t.middleware||[],G(t)];return Object.assign(async a=>h(i,"client",{...o,method:t.method,data:a?.data,headers:a?.headers,context:{}}).then(d=>{if(d.error)throw d.error;return d.result}),{...o,__executeServer:async a=>{const d=a instanceof FormData?k(a):a;return await h(i,"server",{...o,...d}).then(c=>({result:c.result,error:c.error,context:c.sendContext}))}})}}}function k(e){const n=e.get("__TSR_CONTEXT");if(e.delete("__TSR_CONTEXT"),typeof n!="string")return{context:{},data:e};try{return{context:O.parse(n),data:e}}catch{return{data:e}}}function z(e){const n=new Set,t=[],r=o=>{o.forEach(s=>{s.options.middleware&&r(s.options.middleware),n.has(s)||(n.add(s),t.push(s))})};return r(e),t}const f=async(e,n,t)=>e({...n,next:async(r={})=>t({...n,...r,context:{...n.context,...r.context},sendContext:{...n.sendContext,...r.sendContext??{}},headers:I(n.headers,r.headers),result:r.result!==void 0?r.result:n.result,error:r.error??n.error})});function N(e,n){if(e==null)return{};if("~standard"in e){const t=e["~standard"].validate(n);if(t instanceof Promise)throw new Error("Async validation not supported");if(t.issues)throw new Error(JSON.stringify(t.issues,void 0,2));return t.value}if("parse"in e)return e.parse(n);if(typeof e=="function")return e(n);throw new Error("Invalid validator type!")}async function h(e,n,t){const r=z([...P,...e]),o=async s=>{const i=r.shift();if(!i)return s;i.options.validator&&(n!=="client"||i.options.validateClient)&&(s.data=await N(i.options.validator,s.data));const a=n==="client"?i.options.client:i.options.server;return a?f(a,s,async d=>{const l=i.options.clientAfter;if(n==="client"&&l){const c=await o(d);return f(l,{...d,...c},b=>b)}return o(d).catch(c=>{if(S(c)||F(c))return{...d,error:c};throw c})}):o(s)};return o({...t,headers:t.headers||{},sendContext:t.sendContext||{},context:t.context||{}})}function G(e){return{_types:void 0,options:{validator:e.validator,validateClient:e.validateClient,client:async({next:n,sendContext:t,...r})=>{var o;const s=await((o=e.extractedFn)==null?void 0:o.call(e,{...r,context:t}));return n(s)},server:async({next:n,...t})=>{var r;const o=await((r=e.serverFn)==null?void 0:r.call(e,t));return n({...t,result:o})}}}}const L=()=>Promise.resolve().then(()=>x),U=()=>Promise.resolve().then(()=>x),w=T("/")({component:j(U,"component",()=>w.ssr),loader:H(L,"loader")});async function y(){return parseInt($("count")||"0")}const m=u({method:"GET"}).handler(p(_),()=>y()),v=u({method:"POST"}).validator(e=>e).handler(p(g),async({data:e})=>{const n=await y();R("count",String(n+e))}),X=function(){const n=M(),t=w.useLoaderData();return C("button",{type:"button",onClick:()=>{v({data:1}).then(()=>{n.invalidate()})},children:["Add 1 to ",t,"?"]})},B=()=>m();function _(e){return m.__executeServer(e)}function g(e){return v.__executeServer(e)}const x=Object.freeze(Object.defineProperty({__proto__:null,$$function0:_,$$function1:g,component:X,loader:B},Symbol.toStringTag,{value:"Module"}));export{_ as $$function0,g as $$function1,X as component,B as loader};
